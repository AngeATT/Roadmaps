SL : veut dire slow on apprendre au fur et à mesure

=>Pourquoi utiliser let au lieu de var ?
var override les variables sans lever d'exception, var name = 10;
var name = 5; ne va pas poser de porblème

=>Les String sont des tableaux en js mais on ne peut pas les modifier

=> tableaux peuvent contenir des tomates et des oignons

=> comment ajouter à la fin d'un tableau ?
on utilise push(valeur)

=>Comment retirer le dernier element et l'assigner ?
.pop()

=> Comment supprimer le premier et retourner l'élément ?
.shift()

=>Comment ajouter un element au debut du tableau ?
.unshift()

=>Comment créer une fonction ?
-function maFonction(){}

Global Scope And Functions 

=> Comparator : with == 
equality operator, which attempts to convert both values being compared to a common type
1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
" 3" == 3 //true

The strict equality operator does not perform a type conversion.

-Les objets : comment creer ajouter, supprimer modifier ?
*creer un objet : 
myObj = {
"propriete" : "valeur"
}
* comment ajouter une propriete ? :
myObj.prop = "valeur"

*Comment supprimer une propriete ?
delete obj.prop

*Comment modifier une propriété ?: 
obj.prop = nouvelle valeur

Utilite des objets ? 
On peut utiliser un objet lorsqu'on veut faire un check sur des valeurs qu'on connait tous

2 manières d'accéder au propriétés ?
obj.prop
obj[prop]

-Les propriétes sont tjr convertis en string :
obj.hasOwnProperty(prop)

-Accéder aux propriétés d'un objet :
const recordCollection = {
  2548: {
    albumTitle: 'Slippery When Wet',
    artist: 'Bon Jovi',
    tracks: ['Let It Rock', 'You Give Love a Bad Name']
  }}
on va faire recordCollection[id][propriete]
-Toujours accéder aux variables avec myObj[prop]

-The definitive guide :
Pourquoi utiliser des arrows functions ? Arrow functions are most commonly used when you want to pass an unnamed function as an argument to another function.

-Différence entre méthode et fonction ?
lorsqu'une fonction est liée à un objet c'est une méthode

-Afficher des caractères comme émoji et accent :
*decrire directement avec une variable let café ou \u :
caf\u{E9} (ES6) 

-Quel est le soucis avec les variables qui ont des non ASCII ?
*Les caractere non ASCII peuvent avoir différentes interpretations donc deux varibales peuvent avoir la même sémantique mais être "différentes" ne renvoient pas les même valeurs
const café = 1; // This constant is named "caf\u{e9}"
const café = 2; // This constant is different: "cafe\u{301}"
café // => 1: this constant has one value
café // => 2: this indistinguishable constant has a different value

-Numbers :
integer : 1, 10
hexadecimal : 0xff, 0Xabf
binary : 0b0100
octal : 0o1247

-Floating points : 
.58 signifie 0.58 !
6.02e23 // 6.02 × 10²³
1.4738223E-32 // 1.4738223 × 10⁻³²

Standardiser : let billion = 1_000_000_000;

Arithmetiques :
*puissance : ?
Math.pow()
*arrondi au plus pret : ?
Math.round
*arrondi au plus grand : ?
ceil
*arrondi au plus bas : ?
floor
*absolu : ?
Math.abs
*max, min, peuvent prendre 3 champs
*nombre aléatoire entre 0 et 1 : Math.random()
*PI : Math.PI
*racine carré : sqrt()
*Puissance : Math.pow(3,2)
sin, log 

ES6 :
*racine carré de la somme au carré des elements : Math.hypot(x,y,z) !
Log10
log2
*Le signe d'un élément : 
Math.sign(x) -1 0 ou 1
*Supprimer la partie fractionnelle ? 
Math.trunc

Les erreurs sur les nombres en js :
Il n'y a pas dérreurs mais on aura soit NaN, soit des Infinity - et + selon la logique mathématique
Number.POSITIVE_INFINITY ou Number.NEGATIVE_INFINITY

*Convertir en Int :
Number.parseInt(x)

*Convertir en Float :
Number.parseFloat(y)

vérifier que c'est un integer :
Number.isInteger()

-Comment déterminer si une valeur est NaN ?
Math.isNan(x) toute autre opération est fortuite

-Différence entre 0 et -0 1/0 et 1/-0 sont différents

-Problème avec les nombres à virgules 0.3-0.2 ne donne pas 0.1 mais 0.099999998

-BigInt : 10000n 64digits : 2 choses à retenir dessus ?

*Impossible de mélanger les operations avec le BigInt et les autres car il se comporte comme un int donc difficile de rendre un resultat correcte

*Les comparaisons par contre passent

Dates and times : !!
*timestamp that specifies the number of elapsed milli‐seconds since January 1, 1970
*Obtenir la date de maintenant en String : now.ISOString(),
en timeStamp : Date().now() ou getTime()
*Comment obtenir la date en / :
ToLocaleDateString()
ToLocaleTimeString()

Différence entre Date et Date() ? objet et l'autre non, getTime() l'autre now()

-Text :
*Chaque caractère ocupe ? 
	chaque caractère : 16bits
*Certains caractère depasse t'il 16 ?
si un caractère depasse16 on associe 2 de 16bits, le length sera 2 mais c'est un seul caractère

*Comment écrire sur plusieurs lignes ?
Ecrire sur plusieurs lignes avec \ et revenir à la ligne
"lkesklfnlke\
rjerkjre" va nous donner une seule ligne
*Comment utiliser un caractère comme ' ? avec le \
*Comment faire un backspace ? \b
*Comment faire une tabulation ? \t
*Comment faire une newline ? \n
*Tabulation vertical ? \v
*Retour à la ligne sans nouvelle ligne ? \r

String in js api :
======
*Retouner les 3 derniers caractères ? "aklkal".slice(-3)
*Supprimer x premiers caractère ?
string.slice(x)

*Renvoyer un tableau de caractère découper selon quelque chose ?
"aklskdslk".split(" ")

*Index => 
*comment trouver l'index d'une chaine de caractère à partir d'un certain index ?
"jkjezkj".indexOf("j",2)

-Contient : 
*Le String contient ? "jkej".includes("x)
*Le String commence avec ? startsWith("kk")
*Le String se termine avec ? endsWith("nn")

-Modification du String :
Remplacer tout la premiere occurence ?
string.replace("nn","hh")
*Remplacer toutes les occurences ?
string.replaceAll("nn", "hh")

-Inspecter les caractères individuels 
*nombre ASCII d'un caractère ?
charCodeAt(x)
utiliser codePointAt() pour les caractères qui depassent 16 bits

-String padding functions :
*ajouter des caractères au débuts ? 
string.padStart(x) ajoute espace au debut
string.padEnd(x,"*") ajoute x * à la fin

trim, repeat, concat à ne pas oublier

-Strings sont immutables, les operations renvoient de nouveaux strings
-Strings sont des tableaux on peut accéder à des indices
-On peut utiliser `${variableJs}`
On peut en utiliser plusieurs :
`${filename} : ${exception.message}`

-REGEXP: !
*on crée un pattern avec 
let pattern = /\d+/g;
*On peut tester si un string match avec :
pattern.test(string)

*Chercher l'index de la premiere occurrence  d'un pattern ?
string.search(pattern)

*Faire un tableau des strings qui match le pattern ?
string.match(pattern)

*Remplacer ce pattern :
string.replace(pattern)

*Strings diviser par un pattern :
string.split(pattern)

-Boolean :
renvoie faux pour les valeurs suivantes :
undefined, null, "", 0 -0 NaN, 

-Différence entre null et undefined

*null veut dire une abscence de valeur, est un objet quand on utilise typeof
It can be used to indicate “no value” for numbers and strings as well as objects

*undefined It is the value of variables that have not been initialized and
!!!!! the value you get when you query the value of an object property or array element that does not exist.

==Symbols 
Quel est son utilité ?
Avant ES6, les propriétés des objets ne pouvaient être que des stings et il était possible d'override les porpriétés d'un objet dans une autre partie du code avec obj[prop] = ...;
Donc Symbol a été crée et donc let s = Symbol(propname) nous renvoie à chaque fois quelque chose de différent de tel sorte qu'il est immpossible d'accéder, de modifier notre porpriété de cet objet quelque part d'autre dans notre code

Symbol.for :
Symbol.for() always returns the same value when called with the same string. 

The Global Object : !
The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined identifiers that are available to a Java‐Script program.

When the JavaScript interpreter starts (or whenever a web browser
loads a new page), it creates a new global object and gives it an initial set of properties
that define:
• Global constants like undefined, Infinity, and NaN
• Global functions like isNaN(), parseInt() and eval()
• Constructor functions like Date(), RegExp(), String(), Object(), and Array()
(§3.9.2)
• Global objects like Math and JSON (§6.8)

Sur node c'est global, sur les browsers c'est window
Quelque soit le contexte on peut y accéder avec globalThis

28-10-23
3.8==Mutable et immutables
Les pimitives et les stings sont immutables : leurs valeurs ne change pas, on renvoie une nouvelle variable
si on fait toUpperCase() sur un string, on ne va pas modifier ce string
*Comparaison :
les primitives sont comparés par valeur

Les objets eux sont mutables et ils sont comparé par references

==Conversion :
si l'opération invoque un nombre il essaie de conertir les 2 opérandes si possible fait l'opération sinon renvoie un NaN
"", 0, null, undefined , -0, nan sont : faux
-Les espaces annulent la conversion d'un string en nombre : " 25" et "25" sont différents lorsque c'est implicite sinon ils sont égaux
-Conversion explicite avec :  Boolean(), Num
ber(), and String()
-Préciser le nombre après la virgule ?
let x= 12.12552
x.toFixed(2) //12.12
-Donner la forme exponent base 10 ?
x.toExponentiel(2)
-Comment convertir même avec des alphanumerique en integer ou en float ?
parseInt("") et parseFloat("")

*Regles : ne doit pas commencer par autre chose qu'un caractère de la base 2, 8, 10 ou ... à convertit ( exple commence par 0 ou 1 si base 2 sinon ça sort NaN )
*parseInt ne va renvoyer que des int
*parseFloat int comme float
*si c'est en base octal ou hexa va convertire en base 10 sauf si on précise en second arguments en quoi on veut convertir

==Primitive to object 
skip

==Declaration de variables 
Retient qu'il est possible d'utiliser const pour les boucles mais la variables sera const uniquement pour une itération
*Scope :
Block scoped
JavaScript class and function definitions are blocks, and so are the
bodies of if/else statements, while loops, for loops, and so on.

*Qu'en est il de la rédéclaration ?
il est possible de rédéclarer une variable dans un statement mais c'est déconseiller 
if( x == 2){
let x = 3;
console.log(x)}

-Différences entre var et let
cite les 3 majeurs différences entre var et let 
*lorsqu'on déclare avec var on assigne la variable à l'objet global, tandis que let est block scoped
*on peut redeclarer les variables lorsqu'on les déclare avec var
C'est quoi le Hoisting ?
*on peut utiliser une variable avant sa déclaration lorsqu'on la declare avec var : hoisting(la declaration monte au top du fichier)

30-10-23 : j2 : p75
==Destructuring Assignment
*C'est quoi la destructuration ?
Permet d'assigner des valeurs à plusieurs variables
exemple :
let [x,y] = [1,2]; // Same as let x=1, y=2
[x,y] = [x+1,y+1]; // Same as x = x + 1, y = y + 1
[x,y] = [y,x]; // Swap the value of the two variables
[x,y]
A droite un tableau ou un objet et à gauche une structure qui mime l'objet en questino et ainsi donc assigne aux variables les valeurs.
*On peut l'utiliser avec une fonction 
*On peut l'utiliser avec un objet

Utilité évidente 
=> permet de swap rapidement deux variables
=> permet de renvoyer un tableau et d'assigner à des variables les valeurs renvoyés
=>permet de loop sur des propriétés d'un objet

chap 4 Expressions
*C'est quoi ReferenceError ?
Lorsqu'on ne trouve pas la valeur d'un expression simple (exemple variable a non declarer et on l'appelle)

*C'est quoi un TypeError ?
-Cas des expressions :
With either type of property access expression, the expression before the . or [ is first
evaluated. If the value is null or undefined, the expression throws a TypeError
-Cas des fonctions : 
l'opérande gauche avant les () n'est pas une fonction

*Quand utiliser . et quand utiliser [] ?
on utilise . lorsque la propriété et elle n'a pas d'espace ou de caractère spéciaux ou si c'est un tableau

*Si on essaie d'appeler une propriété qui n'existe pas pour une variable on a quelle erreur ?


*Comment éviter cette erreur ? en prod ?
On utilise l'optional chaining :
a?.prop
si a n'est pas null ou undefined on accède à la propriété
a?.func()
si a n'est pas null ou undefined (car ce sont les 2 seulement qui n'ont pas de proprietes)
 et a est un objet qui a la propriété func qui est une func on accède à cette fct 
questions :
si func n'est pas une fonction keskisepas ?
si func est undefined keskisepass ?

*La différence entre typeError et ReferenceError
ReferenceError quand la variable existe mais est undefined ou null
TypeError lorsqu'on a un a.quelquechose et a est undefined ou null

-Invocation expressions : calling or executing a function or a method
*Quand peut on avoir un TypeError lors de l'évaluation d'une fonction, de l'invocation d'une fonction ?

If the value of the function expression is not a function, a TypeError is thrown

*Ordre dans lequel une fonction est évaluée ?
-L'opérande gauche est évalué
-La liste des arguments est evaluée
-La fonction prenant en compte les arguments est évaluer et produit un résultat

*On retourne quoi lorsque la méthode est un void ?
Undefined
*Comment éviter un typeError à l'invocation d'une méthode ?
optional chaining
*Comment on crée un objet ?
let o = {}
Décrit ces 3 opérations : 
o.m() // Regular property access, regular invocation
o?.m() // Conditional property access, regular invocation
o.m?.() // Regular property access, conditional invocation
*Comment modifier l'ordre de précédence des opérateurs ?

Avec des ()

*Règles pour l'addition + ?,
quand est ce qu'il convertit en string ? quand est ce qu'il additionne  des nombres ?

Si il y a au moins un string il va convertir les 2 en string
sinon il va convertir les 2 en string
1 + 2 + " blind mice" // => "3 blind mice"
1 + (2 + " blind mice") // => "12 blind mice"

*Quel est l'ordre des operators en js ?
 
*Comment est évalué l'égalité entre 2 statement ?
NaN value is never equal to any other value même lui même
Comparaison par reference comme en java

*Egalité avec les conversions : == ?
- undefined et null sont égaux
-Si un est un number on convertit l'autre en number aussi
-si un est true ou false on convertit l'autre en 0 ou 1 selon le true ou le false
-objet et string on essaie de convertit l'objet en string

Note in particular that string
comparison is case-sensitive, and all capital ASCII letters are “less than” all lowercase ASCII letters.
asci A-Z 65-90
ascii z-z :  a-z is 97-122

*“Zoo” comes before the string “aardvark”. ? dans une comparaison ? pourquoi ?

!Comment se fait les conversions lors des comparaisons et lors des additions ?

!!Pour les comparaisons, js convertit en nombre si il y a au moins un nombre.
"11" < 3 false
"11" < Nan => false

==The in operator 
*On doit avoir quoi à gauche ? et quoi à droite ?
Si à drotie c'est pas un objet on fait comment ?

==The instanceof operator 
The operator evaluates to true if the leftside object is an instance of the right-side class and evaluates to false otherwise.
d instance of Date par exemple
100

126j1

==Loop for of :
*Quelle condittion il faut remplir pour utiliser for of ?
*Comment itérer à travers un objet via ses keys ? via ses values ?
*Peut on itérer sur les strings ?
*Code pour donner les mots unique d'une phrase ?
*Comment écrire le for/await loop ?
*Quel est la différence entre le for/in et le for of ?
*Sur quel exemples de données en js on peux itérer ?
*Comment donner un nom à des statements ? 
*Quel condition il faut remplir pour executer un for in ?
*Quel classes le for in n'affiche pas ?
*C'est quoi break et break label ? donne un exemple
*Différence entre break et continue ?
*Différence entre un for loop et un while loop ?
*try catch : peut on catch n'importe quelle exception ? si oui cmt
*Particularité du strict code ?
*C'est quoi un module en js ?
*Comment donner un alias à un code js ?

Objects 
*C'est quoi un objet ?
*C'est quoi un prototype ?
*Les 3 propriétés des propriétés des objets ?
*Quel est le prototype des objets crées avec new ? avec l'expression litérale ?
*Prototype chain ?
*Qui n'a pas de propriété prototype ? à quoi sert cette propriété ?
*Créer un objet qui a un prototype donnée ?
*Pourquoi utiliser Object.create ?
*Comment faire passer par copy une référence ?
*Comment accéder à une propriété d'un objet ?
*Comment se passe l'héritage avec Object.create ?
154