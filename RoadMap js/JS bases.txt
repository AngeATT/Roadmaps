2h par jour

=>Pourquoi utiliser let au lieu de var ?
var override les variables sans lever d'exception, var name = 10;
var name = 5; ne va pas poser de porblème

=>Les String sont des tableaux en js mais on ne peut pas les modifier

=> tableaux peuvent contenir des tomates et des oignons

=> comment ajouter à la fin d'un tableau ?
on utilise push(valeur)

=>Comment retirer le dernier element et l'assigner ?
.pop()

=> Comment supprimer le premier et retourner l'élément ?
.shift()

=>Comment ajouter un element au debut du tableau ?
.unshift()

=>Comment créer une fonction ?
-function maFonction(){}

Global Scope And Functions 

=> Comparator : with == 
equality operator, which attempts to convert both values being compared to a common type
1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
" 3" == 3 //true

The strict equality operator does not perform a type conversion.

-Les objets : comment creer ajouter, supprimer modifier ?
*creer un objet : 
myObj = {
"propriete" : "valeur"
}
* comment ajouter une propriete ? :
myObj.prop = "valeur"

*Comment supprimer une propriete ?
delete obj.prop

*Comment modifier une propriété ?: 
obj.prop = nouvelle valeur

Utilite des objets ? 
On peut utiliser un objet lorsqu'on veut faire un check sur des valeurs qu'on connait tous

2 manières d'accéder au propriétés ?
obj.prop
obj[prop]

-Les propriétes sont tjr convertis en string :
obj.hasOwnProperty(prop)

-Accéder aux propriétés d'un objet :
const recordCollection = {
  2548: {
    albumTitle: 'Slippery When Wet',
    artist: 'Bon Jovi',
    tracks: ['Let It Rock', 'You Give Love a Bad Name']
  }}
on va faire recordCollection[id][propriete]
-Toujours accéder aux variables avec myObj[prop]

-The definitive guide :
Pourquoi utiliser des arrows functions ? Arrow functions are most commonly used when you want to pass an unnamed function as an argument to another function.

-Différence entre méthode et fonction ?
lorsqu'une fonction est liée à un objet c'est une méthode

-Afficher des caractères comme émoji et accent :
*decrire directement avec une variable let café ou \u :
caf\u{E9} (ES6) 

-Quel est le soucis avec les variables qui ont des non ASCII ?
*Les caractere non ASCII peuvent avoir différentes interpretations donc deux varibales peuvent avoir la même sémantique mais être "différentes" ne renvoient pas les même valeurs
const café = 1; // This constant is named "caf\u{e9}"
const café = 2; // This constant is different: "cafe\u{301}"
café // => 1: this constant has one value
café // => 2: this indistinguishable constant has a different value

-Numbers :
integer : 1, 10
hexadecimal : 0xff, 0Xabf
binary : 0b0100
octal : 0o1247

-Floating points : 
.58 signifie 0.58 !
6.02e23 // 6.02 × 10²³
1.4738223E-32 // 1.4738223 × 10⁻³²

Standardiser : let billion = 1_000_000_000;

Arithmetiques :
*puissance : ?
Math.pow()
*arrondi au plus pret : ?
Math.round
*arrondi au plus grand : ?
ceil
*arrondi au plus bas : ?
floor
*absolu : ?
Math.abs
*max, min, peuvent prendre 3 champs
*nombre aléatoire entre 0 et 1 : Math.random()
*PI : Math.PI
*racine carré : sqrt()
*Puissance : Math.pow(3,2)
sin, log 

ES6 :
*racine carré de la somme au carré des elements : Math.hypot(x,y,z) !
Log10
log2
*Le signe d'un élément : 
Math.sign(x) -1 0 ou 1
*Supprimer la partie fractionnelle ? 
Math.trunc

Les erreurs sur les nombres en js :
Il n'y a pas dérreurs mais on aura soit NaN, soit des Infinity - et + selon la logique mathématique
Number.POSITIVE_INFINITY ou Number.NEGATIVE_INFINITY

*Convertir en Int :
Number.parseInt(x)

*Convertir en Float :
Number.parseFloat(y)

vérifier que c'est un integer :
Number.isInteger()

-Comment déterminer si une valeur est NaN ?
Math.isNan(x) toute autre opération est fortuite

-Différence entre 0 et -0 1/0 et 1/-0 sont différents

-Problème avec les nombres à virgules 0.3-0.2 ne donne pas 0.1 mais 0.099999998

-BigInt : 10000n 64digits : 2 choses à retenir dessus ?

*Impossible de mélanger les operations avec le BigInt et les autres car il se comporte comme un int donc difficile de rendre un resultat correcte

*Les comparaisons par contre passent

Dates and times : !!
*timestamp that specifies the number of elapsed milli‐seconds since January 1, 1970
*Obtenir la date de maintenant en String : now.ISOString(),
en timeStamp : Date().now() ou getTime()
*Comment obtenir la date en / :
ToLocaleDateString()
ToLocaleTimeString()

Différence entre Date et Date() ? objet et l'autre non, getTime() l'autre now()

-Text :
*Chaque caractère ocupe ? 
	chaque caractère : 16bits
*Certains caractère depasse t'il 16 ?
si un caractère depasse16 on associe 2 de 16bits, le length sera 2 mais c'est un seul caractère

*Comment écrire sur plusieurs lignes ?
Ecrire sur plusieurs lignes avec \ et revenir à la ligne
"lkesklfnlke\
rjerkjre" va nous donner une seule ligne
*Comment utiliser un caractère comme ' ? avec le \
*Comment faire un backspace ? \b
*Comment faire une tabulation ? \t
*Comment faire une newline ? \n
*Tabulation vertical ? \v
*Retour à la ligne sans nouvelle ligne ? \r

String in js api :
======
*Retouner les 3 derniers caractères ? "aklkal".slice(-3)
*Supprimer x premiers caractère ?
string.slice(x)

*Renvoyer un tableau de caractère découper selon quelque chose ?
"aklskdslk".split(" ")

*Index => 
*comment trouver l'index d'une chaine de caractère à partir d'un certain index ?
"jkjezkj".indexOf("j",2)

-Contient : 
*Le String contient ? "jkej".includes("x)
*Le String commence avec ? startsWith("kk")
*Le String se termine avec ? endsWith("nn")

-Modification du String :
Remplacer tout la premiere occurence ?
string.replace("nn","hh")
*Remplacer toutes les occurences ?
string.replaceAll("nn", "hh")

-Inspecter les caractères individuels 
*nombre ASCII d'un caractère ?
charCodeAt(x)
utiliser codePointAt() pour les caractères qui depassent 16 bits

-String padding functions :
*ajouter des caractères au débuts ? 
string.padStart(x) ajoute espace au debut
string.padEnd(x,"*") ajoute x * à la fin

trim, repeat, concat à ne pas oublier

-Strings sont immutables, les operations renvoient de nouveaux strings
-Strings sont des tableaux on peut accéder à des indices
-On peut utiliser `${variableJs}`
On peut en utiliser plusieurs :
`${filename} : ${exception.message}`

-REGEXP: !
*on crée un pattern avec 
let pattern = /\d+/g;
*On peut tester si un string match avec :
pattern.test(string)

*Chercher l'index de la premiere occurrence  d'un pattern ?
string.search(pattern)

*Faire un tableau des strings qui match le pattern ?
string.match(pattern)

*Remplacer ce pattern :
string.replace(pattern)

*Strings diviser par un pattern :
string.split(pattern)

-Boolean :
renvoie faux pour les valeurs suivantes :
undefined, null, "", 0 -0 NaN, 

-Différence entre null et undefined

*null veut dire une abscence de valeur, est un objet quand on utilise typeof
It can be used to indicate “no value” for numbers and strings as well as objects

*undefined It is the value of variables that have not been initialized and
!!!!! the value you get when you query the value of an object property or array element that does not exist.

==Symbols 
Quel est son utilité ?
Avant ES6, les propriétés des objets ne pouvaient être que des stings et il était possible d'override les porpriétés d'un objet dans une autre partie du code avec obj[prop] = ...;
Donc Symbol a été crée et donc let s = Symbol(propname) nous renvoie à chaque fois quelque chose de différent de tel sorte qu'il est immpossible d'accéder, de modifier notre porpriété de cet objet quelque part d'autre dans notre code

Symbol.for :
Symbol.for() always returns the same value when called with the same string. 

The Global Object : !
The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined identifiers that are available to a Java‐Script program.

When the JavaScript interpreter starts (or whenever a web browser
loads a new page), it creates a new global object and gives it an initial set of properties
that define:
• Global constants like undefined, Infinity, and NaN
• Global functions like isNaN(), parseInt() and eval()
• Constructor functions like Date(), RegExp(), String(), Object(), and Array()
(§3.9.2)
• Global objects like Math and JSON (§6.8)

Sur node c'est global, sur les browsers c'est window
Quelque soit le contexte on peut y accéder avec globalThis

28-10-23
3.8==Mutable et immutables
Les pimitives et les stings sont immutables : leurs valeurs ne change pas, on renvoie une nouvelle variable
si on fait toUpperCase() sur un string, on ne va pas modifier ce string
*Comparaison :
les primitives sont comparés par valeur

Les objets eux sont mutables et ils sont comparé par references

==Conversion :
si l'opération invoque un nombre il essaie de conertir les 2 opérandes si possible fait l'opération sinon renvoie un NaN
"", 0, null, undefined , -0, nan sont : faux
-Les espaces annulent la conversion d'un string en nombre : " 25" et "25" sont différents lorsque c'est implicite sinon ils sont égaux
-Conversion explicite avec :  Boolean(), Num
ber(), and String()
-Préciser le nombre après la virgule ?
let x= 12.12552
x.toFixed(2) //12.12
-Donner la forme exponent base 10 ?
x.toExponentiel(2)
-Comment convertir même avec des alphanumerique en integer ou en float ?
parseInt("") et parseFloat("")

*Regles : ne doit pas commencer par autre chose qu'un caractère de la base 2, 8, 10 ou ... à convertit ( exple commence par 0 ou 1 si base 2 sinon ça sort NaN )
*parseInt ne va renvoyer que des int
*parseFloat int comme float
*si c'est en base octal ou hexa va convertire en base 10 sauf si on précise en second arguments en quoi on veut convertir

==Primitive to object 
skip

==Declaration de variables 
Retient qu'il est possible d'utiliser const pour les boucles mais la variables sera const uniquement pour une itération
*Scope :
Block scoped
JavaScript class and function definitions are blocks, and so are the
bodies of if/else statements, while loops, for loops, and so on.

*Qu'en est il de la rédéclaration ?
il est possible de rédéclarer une variable dans un statement mais c'est déconseiller 
if( x == 2){
let x = 3;
console.log(x)}

-Différences entre var et let
cite les 3 majeurs différences entre var et let 
*lorsqu'on déclare avec var on assigne la variable à l'objet global, tandis que let est block scoped
*on peut redeclarer les variables lorsqu'on les déclare avec var
C'est quoi le Hoisting ?
*on peut utiliser une variable avant sa déclaration lorsqu'on la declare avec var : hoisting(la declaration monte au top du fichier)

==Destructuring Assignment
let [x,y] = [1,2]; // Same as let x=1, y=2
[x,y] = [x+1,y+1]; // Same as x = x + 1, y = y + 1
[x,y] = [y,x]; // Swap the value of the two variables
[x,y]
75

chap 4 Expressions
*C'est quoi ReferenceError ?
Lorsqu'on ne trouve pas la valeur d'un expression simple

*C'est quoi un TypeError ?
*Comment se passe l'évaluation de l'accès à une propriété d'un tableau ou d'un objet ?
*Comment éviter cette erreur ? en prod ?
*C'est quoi l'optional chaining ?
*La différence entre typeError et ReferenceError

-Invocation expressions : calling or executing a function or a method
*Quand peut on avoir un TypeError lors de l'évaluation d'une fonction, de l'invocation d'une fonction
*Ordre dans lequel l'invocation d'une expression se déroule.
*On retourne quoi lorsque la méthode est un void ?
*Comment éviter un typeError à l'invocation d'une méthode ?
*COmment on crée un objet ?
Décrit ces 3 opérations : 
o.m() // Regular property access, regular invocation
o?.m() // Conditional property access, regular invocation
o.m?.() // Regular property access, conditional invocation
*Comment modifier l'ordre de précédence des opérateurs ?
*Règles pour l'addition + ?, quand il convertit en string quand il additionne  des nombres ?